package com.socrata.http

import scala.{collection => sc}
import scala.io.Codec

import java.nio.charset.CodingErrorAction
import javax.activation.MimeType

import com.ning.http.client.RequestBuilderBase

class StandardConsumer[T](builder: RequestBuilderBase[_], auth: Authorization, bodyConsumer: Codec => BodyConsumer[T]) extends StatusConsumer[Retryable[T]] {
  def apply(status: Status): Either[HeadersConsumer[Retryable[T]], Retryable[T]] = {
    if(status.isSuccess) success(status)
    else if(status.isRedirect) redirect(status)
    else if(status.isClientError) clientError(status)
    else if(status.isServerError) serverError(status)
    else // throw something
      error("NYI")
  }

  private def success(status: Status) = {
    // 200: normal, just proceed with upload
    // 202: 202 handling
    // 203: same as 200
    // 204: almost the same as 200 but after header-processing call the bodyConsumer with an empty array and isLast=true
    // 205: same as 204
    // 206: will not be generated by SODA2
    status.code match {
      case 200 => Left(new OKHeadersConsumer(bodyConsumer))
    }
  }

  private def redirect(status: Status) = {
    // 300: will not be generated by SODA2
    // 301, 302, 307: if this was a GET, redirect.  Otherwise fail with "unexepected redirect".
    // 303: redirect
    // 304: we will never send a conditional GET and therefore this will never be sent back
    // 305, 306: we will never receive this from a SODA2 server
    error("NYI")
  }

  private def clientError(status: Status) = {
    // fail with appropriate error
    error("NYI")
  }

  private def serverError(status: Status) = {
    // fail with appropriate error
    error("NYI")
  }
}

class WrappedBodyConsumer[T](underlying: BodyConsumer[T]) extends BodyConsumer[Retryable[T]] {
  def apply(bytes: Array[Byte], isLast: Boolean) = underlying(bytes, isLast).left.map(new WrappedBodyConsumer(_)).right.map(v => Right(v))
}

sealed abstract class NewRequest[T]

class OKHeadersConsumer[T](bodyConsumer: Codec => BodyConsumer[T]) extends HeadersConsumer[Retryable[T]] {
  def codecFor(charset: String) =
    Codec(charset).onMalformedInput(CodingErrorAction.REPLACE).onUnmappableCharacter(CodingErrorAction.REPLACE)

  def apply(headers: sc.Map[String, Seq[String]]): Either[BodyConsumer[Retryable[T]], Retryable[T]] = {
    headers.get("Content-Type").map(_.last) match {
      case Some(contentType) =>
        val mimeType = new MimeType(contentType)
        if(mimeType.getBaseType != "application/json") error("NYI")
        val charset = Option(mimeType.getParameter("charset")).getOrElse("iso-8859-1")
        val realBodyConsumer = bodyConsumer(codecFor(charset))
        Left(new WrappedBodyConsumer(realBodyConsumer))
      case None =>
        error("NYI")
    }
  }
}
